import * as Cesium from "cesium";
import type { Jammer } from "../Jammer/Jammer";
import type { Frequency } from "../Jammer/JammerRelatedEnums";
import type { GeoPoint } from "../../Messages/AllTypes";
import { JammerColorOptionsManager } from "./JammerColorOptions";

export class JammerEntity {
    private viewer: Cesium.Viewer | null;
    private jammerEntity: Cesium.Entity | null;
    private jammer: Jammer;
    private rangeEntity: Cesium.Entity | null = null;
    private omniEntity: Cesium.Entity | null = null;
    private directionalEntity: Cesium.Entity | null = null;
    private beamWidthDeg: number = 40;
    private directionDeg: number = 0;
    private leftWallEntity: Cesium.Entity | null = null;
    private rightWallEntity: Cesium.Entity | null = null;


    constructor(viewer: Cesium.Viewer, jammer: Jammer) {
        this.viewer = viewer;
        this.jammerEntity = null;
        this.jammer = jammer;
        this.createEntities();
    }

    setJammer(jammer: Jammer) {
        this.jammer = jammer;
    }

    getJammer(): Jammer {
        return this.jammer;
    }

    setEntityNull() {
        this.jammerEntity = null;
    }

    removeEntity() {
        if (this.jammerEntity) {
        this.viewer?.entities.remove(this.jammerEntity);
        this.jammerEntity = null;
        }
    }

    getEntity(): Cesium.Entity | null {
        return this.jammerEntity;
    }

    // update position
    updatePosition(position: GeoPoint) {
        this.jammer.position = position;
        const newPosition = Cesium.Cartesian3.fromDegrees(this.jammer.position.longitude, this.jammer.position.latitude, this.jammer.position.altitude);
        if (this.jammerEntity) {
        this.jammerEntity.position = new Cesium.ConstantPositionProperty(newPosition);
        }

        if (this.rangeEntity) {
            this.rangeEntity.position = new Cesium.ConstantPositionProperty(newPosition);
        }

        if (this.omniEntity) {
            this.omniEntity.position = new Cesium.ConstantPositionProperty(newPosition);
        }
        if (this.directionalEntity) {
            this.directionalEntity.position = new Cesium.ConstantPositionProperty(newPosition);
        }

    }

    // update radius
    updateRadius(radius: number) {
        this.jammer.radius = radius;
        if (this.rangeEntity && this.rangeEntity.cylinder) {
        this.rangeEntity.cylinder.topRadius = new Cesium.ConstantProperty(radius);
        this.rangeEntity.cylinder.bottomRadius = new Cesium.ConstantProperty(radius);
        }
        if (this.omniEntity && this.omniEntity.ellipsoid) {
            this.omniEntity.ellipsoid.radii = new Cesium.ConstantProperty(new Cesium.Cartesian3(radius, radius, radius));
        }
        if (this.directionalEntity && this.directionalEntity.ellipsoid) {
            this.directionalEntity.ellipsoid.radii = new Cesium.ConstantProperty(new Cesium.Cartesian3(radius, radius, radius));
        }
    }

    // update frequencies
    updateFrequencies(frequencies: Frequency[]) {
        this.jammer.supportedFrequencies = frequencies;
    }

    createEntities() {
        if (this.viewer === null || this.jammer === null)
        return;

        const position = Cesium.Cartesian3.fromDegrees(
        this.jammer.position.longitude,
        this.jammer.position.latitude,
        this.jammer.position.altitude
        );

        const options =  JammerColorOptionsManager.getJammerColorOptionsByString(this.jammer.status)
        this.jammerEntity = this.viewer.entities.add({
                position: new Cesium.ConstantPositionProperty(position),
                model: {
                    uri: `/models/Jammer.glb`,
                    scale: 25.0,
                    minimumPixelSize: 64,
                    color:options?.color.withAlpha(1),
                    colorBlendMode: Cesium.ColorBlendMode.MIX,
                    colorBlendAmount: 0.1,
                        silhouetteColor: options?.outlineColor,
                        silhouetteSize: 2,
                    }
        });

        this.rangeEntity = this.viewer.entities.add({
                position: new Cesium.ConstantPositionProperty(position),
                cylinder: {
                    length: 20,
                    topRadius: this.jammer.radius,
                    bottomRadius: this.jammer.radius,

                    material: Cesium.Color.TRANSPARENT,
                    outline: true,
                    outlineColor: Cesium.Color.YELLOW,
                    outlineWidth: 2,
                }
            });

        this.omniEntity = this.viewer.entities.add({
                position: new Cesium.ConstantPositionProperty(position),
                ellipsoid: {
                    radii: new Cesium.Cartesian3(
                    this.jammer.radius,
                    this.jammer.radius,
                    this.jammer.radius
                    ),
                    material: Cesium.Color.RED.withAlpha(0.6),
                    outline: false
                },
                show: false // starting as hidden.
            });

        this.directionalEntity = this.viewer.entities.add({
                position: new Cesium.ConstantPositionProperty(position),
                ellipsoid: {
                    radii: new Cesium.Cartesian3(
                    this.jammer.radius,
                    this.jammer.radius,
                    this.jammer.radius
                    ),
                    material: Cesium.Color.RED.withAlpha(0.6),
                },
                show: false // starting as hidden.
            });


// דופן שמאל
this.leftWallEntity = this.viewer.entities.add({
    show: false,
    wall: {
        positions: new Cesium.CallbackProperty(() => this.getWallEntityOptions(true).positions, false),
        minimumHeights: new Cesium.CallbackProperty(() => this.getWallEntityOptions(true).minHeights, false),
        maximumHeights: new Cesium.CallbackProperty(() => this.getWallEntityOptions(true).maxHeights, false),
        material: Cesium.Color.RED.withAlpha(0.6),
        outline: false
    }
});

// דופן ימין
this.rightWallEntity = this.viewer.entities.add({
    show: false,
    wall: {
        positions: new Cesium.CallbackProperty(() => this.getWallEntityOptions(false).positions, false),
        minimumHeights: new Cesium.CallbackProperty(() => this.getWallEntityOptions(false).minHeights, false),
        maximumHeights: new Cesium.CallbackProperty(() => this.getWallEntityOptions(false).maxHeights, false),
        material: Cesium.Color.RED.withAlpha(0.6),
        outline: false
    }
});

        this.showDirectional(90);
    }

    removeEntities(){
        if(this.jammerEntity){
            this.viewer?.entities.remove(this.jammerEntity)
        }

        if (this.rangeEntity){
        this.viewer?.entities.remove(this.rangeEntity);
        }

        if (this.omniEntity) {
            this.viewer?.entities.remove(this.omniEntity);
        }

        if (this.directionalEntity) {
            this.viewer?.entities.remove(this.directionalEntity);
        }

        if(this.leftWallEntity){
            this.viewer?.entities.remove(this.leftWallEntity);
        }

        if(this.rightWallEntity){
            this.viewer?.entities.remove(this.rightWallEntity);
        }

        this.jammerEntity = null;
        this.rangeEntity = null;
        this.omniEntity = null;
        this.directionalEntity = null;
        this.leftWallEntity = null
        this.rightWallEntity = null

    }

    showOmni() {
        if (this.omniEntity) {
            this.omniEntity.show = true;
        }
    }

    hideOmni() {
        if (this.omniEntity) {
            this.omniEntity.show = false;
        }
    }

    showDirectional(directionDeg: number) {
        if (!this.directionalEntity?.ellipsoid) return;
        
        this.directionDeg = directionDeg;

        if (this.leftWallEntity) this.leftWallEntity.show = true;
    if (this.rightWallEntity) this.rightWallEntity.show = true;
        const half = this.beamWidthDeg / 2;

        const minClock = Cesium.Math.toRadians(this.directionDeg - half);
        const maxClock = Cesium.Math.toRadians(this.directionDeg + half);

        this.directionalEntity.ellipsoid.minimumClock =
            new Cesium.ConstantProperty(minClock);

        this.directionalEntity.ellipsoid.maximumClock =
            new Cesium.ConstantProperty(maxClock);

        this.directionalEntity.show = true;
    }

    hideDirectional() {
        if (this.directionalEntity) {
            this.directionalEntity.show = false;
        }
        if (this.leftWallEntity) this.leftWallEntity.show = false;
    if (this.rightWallEntity) this.rightWallEntity.show = false;
    }


   private getWallEntityOptions(isLeft: boolean) {
        const angle = isLeft ? 
            this.directionDeg - (this.beamWidthDeg / 2 ) : 
            this.directionDeg + (this.beamWidthDeg / 2 );
        
        const radius = this.jammer.radius;
        const center = this.jammer.position;
        const angleRad = Cesium.Math.toRadians(angle);

        const positions: Cesium.Cartesian3[] = [];
        const minHeights: number[] = [];
        const maxHeights: number[] = [];

        const samples = 16; // הגדלתי ל-16 נקודות כדי שהקימור יהיה חלק מאוד
        for (let i = 0; i <= samples; i++) {
            const distance = (i / samples) * radius;
            
            const lon = center.longitude + (distance * Math.cos(angleRad) / 111320);
            const lat = center.latitude + (distance * Math.sin(angleRad) / 110540);
            
            positions.push(Cesium.Cartesian3.fromDegrees(lon, lat));
            
            // חישוב חצי הגובה בנקודה הזו (כדי שיהיה סימטרי למעלה ולמטה)
            const halfHeight = Math.sqrt(Math.max(0, Math.pow(radius, 2) - Math.pow(distance, 2)));
            
            maxHeights.push(center.altitude + halfHeight); // התקרה של הקיר
            minHeights.push(center.altitude - halfHeight); // הרצפה של הקיר
        }

        return { positions, minHeights, maxHeights };
    }
}